# ğŸ”„ JieDimension Toolkit - çƒ­æ›´æ–°è®¾è®¡æ–¹æ¡ˆ

> **ç‰ˆæœ¬**: v1.0  
> **æ—¥æœŸ**: 2025-10-09  
> **çŠ¶æ€**: è®¾è®¡é˜¶æ®µ

---

## ğŸ“‹ éœ€æ±‚åˆ†æ

### ç”¨æˆ·éœ€æ±‚
- ç”¨æˆ·æ— éœ€é‡æ–°ä¸‹è½½å®Œæ•´å®‰è£…åŒ…
- åº”ç”¨å†…ä¸€é”®æ›´æ–°
- æ›´æ–°è¿‡ç¨‹è‡ªåŠ¨åŒ–
- ä¿ç•™ç”¨æˆ·æ•°æ®å’Œé…ç½®

### æŠ€æœ¯æŒ‘æˆ˜
- **exeæ— æ³•è‡ªæˆ‘æ›´æ–°**: Windowsä¸å…è®¸æ­£åœ¨è¿è¡Œçš„exeä¿®æ”¹è‡ªèº«
- **æ•°æ®è¿ç§»**: éœ€è¦ä¿ç•™æ•°æ®åº“å’Œé…ç½®
- **ç‰ˆæœ¬å…¼å®¹**: æ–°æ—§ç‰ˆæœ¬æ•°æ®ç»“æ„å¯èƒ½ä¸åŒ
- **ç½‘ç»œé—®é¢˜**: ä¸‹è½½å¤±è´¥éœ€è¦é‡è¯•æœºåˆ¶

---

## ğŸ¯ æ¨èæ–¹æ¡ˆï¼šåŒè¿›ç¨‹æ›´æ–°

### åŸç†
1. **ä¸»ç¨‹åº**: æ£€æŸ¥æ›´æ–° â†’ ä¸‹è½½æ–°ç‰ˆæœ¬ â†’ å¯åŠ¨æ›´æ–°ç¨‹åº â†’ é€€å‡º
2. **æ›´æ–°ç¨‹åº**: ç­‰å¾…ä¸»ç¨‹åºé€€å‡º â†’ æ›¿æ¢exe â†’ é‡å¯ä¸»ç¨‹åº

### ä¼˜åŠ¿
- âœ… å®‰å…¨å¯é ï¼ˆä¸»ç¨‹åºé€€å‡ºåæ‰æ›´æ–°ï¼‰
- âœ… ç”¨æˆ·ä½“éªŒå¥½ï¼ˆä¸€é”®æ›´æ–°ï¼‰
- âœ… æ”¯æŒæ–­ç‚¹ç»­ä¼ 
- âœ… å›æ»šæœºåˆ¶ï¼ˆå¤‡ä»½æ—§ç‰ˆæœ¬ï¼‰

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### 1. ç‰ˆæœ¬æœåŠ¡å™¨
```
https://your-server.com/updates/
â”œâ”€â”€ latest.json          # æœ€æ–°ç‰ˆæœ¬ä¿¡æ¯
â”œâ”€â”€ v1.16.0.zip         # ç‰ˆæœ¬åŒ…
â”œâ”€â”€ v1.17.0.zip
â””â”€â”€ changelog.json      # æ›´æ–°æ—¥å¿—
```

#### latest.json æ ¼å¼
```json
{
  "version": "1.17.0",
  "release_date": "2025-10-15",
  "download_url": "https://your-server.com/updates/v1.17.0.zip",
  "file_size": 52428800,
  "md5": "abc123...",
  "min_version": "1.15.0",
  "changelog": [
    "æ–°å¢: æŠ–éŸ³æ’ä»¶æ”¯æŒ",
    "ä¿®å¤: é—²é±¼å‘å¸ƒBug",
    "ä¼˜åŒ–: æå‡50%æ€§èƒ½"
  ],
  "force_update": false
}
```

### 2. æ›´æ–°æ¨¡å—ç»“æ„
```
core/
â”œâ”€â”€ updater.py              # æ›´æ–°æ£€æŸ¥å™¨ï¼ˆä¸»ç¨‹åºï¼‰
â”œâ”€â”€ update_installer.py     # æ›´æ–°å®‰è£…å™¨ï¼ˆç‹¬ç«‹exeï¼‰
â””â”€â”€ version.py              # ç‰ˆæœ¬ç®¡ç†

utils/
â””â”€â”€ download_manager.py     # ä¸‹è½½ç®¡ç†å™¨
```

---

## ğŸ’» ä»£ç å®ç°

### 1. ç‰ˆæœ¬ç®¡ç†å™¨ (core/version.py)

```python
"""
ç‰ˆæœ¬ç®¡ç†æ¨¡å—
"""
import json
from pathlib import Path
from typing import Dict, Optional, Tuple

class VersionManager:
    """ç‰ˆæœ¬ç®¡ç†å™¨"""
    
    CURRENT_VERSION = "1.16.0"  # å½“å‰ç‰ˆæœ¬
    VERSION_FILE = "version.json"
    
    @classmethod
    def get_current_version(cls) -> str:
        """è·å–å½“å‰ç‰ˆæœ¬"""
        return cls.CURRENT_VERSION
    
    @classmethod
    def parse_version(cls, version: str) -> Tuple[int, int, int]:
        """è§£æç‰ˆæœ¬å·"""
        try:
            major, minor, patch = version.split('.')
            return int(major), int(minor), int(patch)
        except:
            return (0, 0, 0)
    
    @classmethod
    def compare_versions(cls, v1: str, v2: str) -> int:
        """
        æ¯”è¾ƒç‰ˆæœ¬å·
        
        Returns:
            1: v1 > v2
            0: v1 == v2
           -1: v1 < v2
        """
        v1_tuple = cls.parse_version(v1)
        v2_tuple = cls.parse_version(v2)
        
        if v1_tuple > v2_tuple:
            return 1
        elif v1_tuple < v2_tuple:
            return -1
        else:
            return 0
    
    @classmethod
    def is_newer(cls, new_version: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦æœ‰æ–°ç‰ˆæœ¬"""
        return cls.compare_versions(new_version, cls.CURRENT_VERSION) > 0
```

### 2. æ›´æ–°æ£€æŸ¥å™¨ (core/updater.py)

```python
"""
æ›´æ–°æ£€æŸ¥å’Œä¸‹è½½æ¨¡å—
"""
import json
import asyncio
import aiohttp
import hashlib
from pathlib import Path
from typing import Optional, Dict, Callable
import logging

from core.version import VersionManager

logger = logging.getLogger(__name__)

class UpdateChecker:
    """æ›´æ–°æ£€æŸ¥å™¨"""
    
    def __init__(self, update_url: str = "https://your-server.com/updates/latest.json"):
        self.update_url = update_url
        self.version_manager = VersionManager()
        
    async def check_for_updates(self) -> Optional[Dict]:
        """
        æ£€æŸ¥æ›´æ–°
        
        Returns:
            æ›´æ–°ä¿¡æ¯å­—å…¸ï¼Œæ— æ›´æ–°è¿”å›None
        """
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(self.update_url, timeout=10) as response:
                    if response.status == 200:
                        update_info = await response.json()
                        
                        # æ£€æŸ¥æ˜¯å¦æœ‰æ–°ç‰ˆæœ¬
                        if self.version_manager.is_newer(update_info['version']):
                            logger.info(f"å‘ç°æ–°ç‰ˆæœ¬: {update_info['version']}")
                            return update_info
                        else:
                            logger.info("å½“å‰å·²æ˜¯æœ€æ–°ç‰ˆæœ¬")
                            return None
                    else:
                        logger.error(f"æ£€æŸ¥æ›´æ–°å¤±è´¥: HTTP {response.status}")
                        return None
        except Exception as e:
            logger.error(f"æ£€æŸ¥æ›´æ–°å¼‚å¸¸: {e}")
            return None
    
    async def download_update(
        self, 
        download_url: str, 
        save_path: Path,
        progress_callback: Optional[Callable] = None
    ) -> bool:
        """
        ä¸‹è½½æ›´æ–°æ–‡ä»¶
        
        Args:
            download_url: ä¸‹è½½é“¾æ¥
            save_path: ä¿å­˜è·¯å¾„
            progress_callback: è¿›åº¦å›è°ƒå‡½æ•°(downloaded, total)
            
        Returns:
            æ˜¯å¦ä¸‹è½½æˆåŠŸ
        """
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(download_url) as response:
                    if response.status != 200:
                        logger.error(f"ä¸‹è½½å¤±è´¥: HTTP {response.status}")
                        return False
                    
                    total_size = int(response.headers.get('content-length', 0))
                    downloaded = 0
                    
                    # åˆ›å»ºä¿å­˜ç›®å½•
                    save_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # ä¸‹è½½æ–‡ä»¶
                    with open(save_path, 'wb') as f:
                        async for chunk in response.content.iter_chunked(8192):
                            f.write(chunk)
                            downloaded += len(chunk)
                            
                            # å›è°ƒè¿›åº¦
                            if progress_callback:
                                progress_callback(downloaded, total_size)
                    
                    logger.info(f"ä¸‹è½½å®Œæˆ: {save_path}")
                    return True
                    
        except Exception as e:
            logger.error(f"ä¸‹è½½å¼‚å¸¸: {e}")
            return False
    
    def verify_file(self, file_path: Path, expected_md5: str) -> bool:
        """
        éªŒè¯æ–‡ä»¶MD5
        
        Args:
            file_path: æ–‡ä»¶è·¯å¾„
            expected_md5: æœŸæœ›çš„MD5å€¼
            
        Returns:
            æ˜¯å¦éªŒè¯é€šè¿‡
        """
        try:
            md5 = hashlib.md5()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(8192), b''):
                    md5.update(chunk)
            
            actual_md5 = md5.hexdigest()
            if actual_md5 == expected_md5:
                logger.info("æ–‡ä»¶æ ¡éªŒé€šè¿‡")
                return True
            else:
                logger.error(f"æ–‡ä»¶æ ¡éªŒå¤±è´¥: {actual_md5} != {expected_md5}")
                return False
                
        except Exception as e:
            logger.error(f"æ–‡ä»¶æ ¡éªŒå¼‚å¸¸: {e}")
            return False


class UpdateManager:
    """æ›´æ–°ç®¡ç†å™¨"""
    
    def __init__(self):
        self.checker = UpdateChecker()
        self.update_dir = Path("updates")
        self.backup_dir = Path("backup")
        
    async def check_and_download(
        self, 
        progress_callback: Optional[Callable] = None
    ) -> Optional[Path]:
        """
        æ£€æŸ¥å¹¶ä¸‹è½½æ›´æ–°
        
        Args:
            progress_callback: è¿›åº¦å›è°ƒ
            
        Returns:
            ä¸‹è½½çš„æ›´æ–°åŒ…è·¯å¾„ï¼Œæ— æ›´æ–°è¿”å›None
        """
        # æ£€æŸ¥æ›´æ–°
        update_info = await self.checker.check_for_updates()
        if not update_info:
            return None
        
        # ä¸‹è½½æ›´æ–°
        version = update_info['version']
        download_url = update_info['download_url']
        save_path = self.update_dir / f"v{version}.zip"
        
        success = await self.checker.download_update(
            download_url, 
            save_path, 
            progress_callback
        )
        
        if not success:
            return None
        
        # éªŒè¯æ–‡ä»¶
        if not self.checker.verify_file(save_path, update_info['md5']):
            save_path.unlink()  # åˆ é™¤æŸåçš„æ–‡ä»¶
            return None
        
        return save_path
    
    def install_update(self, update_package: Path) -> bool:
        """
        å®‰è£…æ›´æ–°ï¼ˆè°ƒç”¨æ›´æ–°ç¨‹åºï¼‰
        
        Args:
            update_package: æ›´æ–°åŒ…è·¯å¾„
            
        Returns:
            æ˜¯å¦æˆåŠŸå¯åŠ¨æ›´æ–°ç¨‹åº
        """
        import subprocess
        import sys
        
        try:
            # å¯åŠ¨æ›´æ–°ç¨‹åº
            updater_exe = Path("update_installer.exe")
            if not updater_exe.exists():
                logger.error("æ›´æ–°ç¨‹åºä¸å­˜åœ¨")
                return False
            
            # å‚æ•°ï¼šæ›´æ–°åŒ…è·¯å¾„ã€ä¸»ç¨‹åºè·¯å¾„
            main_exe = Path(sys.executable)
            
            subprocess.Popen([
                str(updater_exe),
                str(update_package),
                str(main_exe)
            ])
            
            logger.info("æ›´æ–°ç¨‹åºå·²å¯åŠ¨")
            return True
            
        except Exception as e:
            logger.error(f"å¯åŠ¨æ›´æ–°ç¨‹åºå¤±è´¥: {e}")
            return False
```

### 3. æ›´æ–°å®‰è£…å™¨ (core/update_installer.py)

```python
"""
æ›´æ–°å®‰è£…å™¨ï¼ˆç‹¬ç«‹ç¨‹åºï¼‰
"""
import sys
import time
import shutil
import zipfile
from pathlib import Path
import psutil

def wait_for_process_exit(process_path: Path, timeout: int = 30):
    """ç­‰å¾…è¿›ç¨‹é€€å‡º"""
    process_name = process_path.name
    
    start_time = time.time()
    while time.time() - start_time < timeout:
        # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
        found = False
        for proc in psutil.process_iter(['name', 'exe']):
            try:
                if proc.info['name'] == process_name:
                    found = True
                    break
            except:
                pass
        
        if not found:
            return True
        
        time.sleep(0.5)
    
    return False

def backup_current_version(exe_path: Path, backup_dir: Path):
    """å¤‡ä»½å½“å‰ç‰ˆæœ¬"""
    backup_dir.mkdir(parents=True, exist_ok=True)
    backup_path = backup_dir / f"{exe_path.stem}_backup.exe"
    shutil.copy2(exe_path, backup_path)
    print(f"å·²å¤‡ä»½åˆ°: {backup_path}")

def install_update(update_zip: Path, target_dir: Path):
    """å®‰è£…æ›´æ–°"""
    print(f"è§£å‹æ›´æ–°åŒ…: {update_zip}")
    
    with zipfile.ZipFile(update_zip, 'r') as zip_ref:
        zip_ref.extractall(target_dir)
    
    print("æ›´æ–°å®‰è£…å®Œæˆ")

def restart_application(exe_path: Path):
    """é‡å¯åº”ç”¨"""
    import subprocess
    print(f"é‡å¯åº”ç”¨: {exe_path}")
    subprocess.Popen([str(exe_path)])

def main():
    """ä¸»å‡½æ•°"""
    if len(sys.argv) < 3:
        print("ç”¨æ³•: update_installer.exe <update_zip> <main_exe>")
        sys.exit(1)
    
    update_zip = Path(sys.argv[1])
    main_exe = Path(sys.argv[2])
    
    print("=" * 50)
    print("JieDimension Toolkit - æ›´æ–°å®‰è£…å™¨")
    print("=" * 50)
    
    # 1. ç­‰å¾…ä¸»ç¨‹åºé€€å‡º
    print("\nç­‰å¾…ä¸»ç¨‹åºé€€å‡º...")
    if not wait_for_process_exit(main_exe):
        print("é”™è¯¯: ä¸»ç¨‹åºæœªèƒ½æ­£å¸¸é€€å‡º")
        sys.exit(1)
    
    time.sleep(1)  # é¢å¤–ç­‰å¾…
    
    # 2. å¤‡ä»½å½“å‰ç‰ˆæœ¬
    print("\nå¤‡ä»½å½“å‰ç‰ˆæœ¬...")
    backup_dir = main_exe.parent / "backup"
    try:
        backup_current_version(main_exe, backup_dir)
    except Exception as e:
        print(f"è­¦å‘Š: å¤‡ä»½å¤±è´¥ - {e}")
    
    # 3. å®‰è£…æ›´æ–°
    print("\nå®‰è£…æ›´æ–°...")
    try:
        install_update(update_zip, main_exe.parent)
    except Exception as e:
        print(f"é”™è¯¯: å®‰è£…å¤±è´¥ - {e}")
        sys.exit(1)
    
    # 4. æ¸…ç†æ›´æ–°åŒ…
    print("\næ¸…ç†æ›´æ–°åŒ…...")
    try:
        update_zip.unlink()
    except:
        pass
    
    # 5. é‡å¯åº”ç”¨
    print("\né‡å¯åº”ç”¨...")
    time.sleep(1)
    restart_application(main_exe)
    
    print("\næ›´æ–°å®Œæˆï¼")
    time.sleep(2)

if __name__ == "__main__":
    main()
```

### 4. GUIæ›´æ–°ç•Œé¢ (ui/update_dialog.py)

```python
"""
æ›´æ–°å¯¹è¯æ¡†
"""
import customtkinter as ctk
import asyncio
from pathlib import Path
from typing import Optional

from core.updater import UpdateManager

class UpdateDialog(ctk.CTkToplevel):
    """æ›´æ–°å¯¹è¯æ¡†"""
    
    def __init__(self, parent, update_info: dict):
        super().__init__(parent)
        
        self.update_info = update_info
        self.update_manager = UpdateManager()
        self.download_task = None
        
        self.setup_ui()
        
    def setup_ui(self):
        """è®¾ç½®ç•Œé¢"""
        self.title("å‘ç°æ–°ç‰ˆæœ¬")
        self.geometry("500x400")
        self.resizable(False, False)
        
        # ç‰ˆæœ¬ä¿¡æ¯
        info_frame = ctk.CTkFrame(self)
        info_frame.pack(fill="x", padx=20, pady=20)
        
        ctk.CTkLabel(
            info_frame,
            text=f"ğŸ‰ å‘ç°æ–°ç‰ˆæœ¬ v{self.update_info['version']}",
            font=("Microsoft YaHei UI", 16, "bold")
        ).pack(pady=10)
        
        ctk.CTkLabel(
            info_frame,
            text=f"å‘å¸ƒæ—¥æœŸ: {self.update_info['release_date']}",
            font=("Microsoft YaHei UI", 12)
        ).pack()
        
        size_mb = self.update_info['file_size'] / (1024 * 1024)
        ctk.CTkLabel(
            info_frame,
            text=f"æ›´æ–°å¤§å°: {size_mb:.1f} MB",
            font=("Microsoft YaHei UI", 12)
        ).pack()
        
        # æ›´æ–°æ—¥å¿—
        changelog_frame = ctk.CTkFrame(self)
        changelog_frame.pack(fill="both", expand=True, padx=20, pady=10)
        
        ctk.CTkLabel(
            changelog_frame,
            text="ğŸ“ æ›´æ–°å†…å®¹",
            font=("Microsoft YaHei UI", 14, "bold")
        ).pack(pady=5)
        
        changelog_text = ctk.CTkTextbox(changelog_frame, height=150)
        changelog_text.pack(fill="both", expand=True, padx=10, pady=5)
        
        for item in self.update_info['changelog']:
            changelog_text.insert("end", f"â€¢ {item}\n")
        changelog_text.configure(state="disabled")
        
        # è¿›åº¦æ¡
        self.progress_frame = ctk.CTkFrame(self)
        self.progress_frame.pack(fill="x", padx=20, pady=10)
        
        self.progress_bar = ctk.CTkProgressBar(self.progress_frame)
        self.progress_bar.pack(fill="x", pady=5)
        self.progress_bar.set(0)
        
        self.progress_label = ctk.CTkLabel(
            self.progress_frame,
            text="å‡†å¤‡ä¸‹è½½...",
            font=("Microsoft YaHei UI", 10)
        )
        self.progress_label.pack()
        
        # éšè—è¿›åº¦æ¡
        self.progress_frame.pack_forget()
        
        # æŒ‰é’®
        button_frame = ctk.CTkFrame(self)
        button_frame.pack(fill="x", padx=20, pady=10)
        
        self.update_btn = ctk.CTkButton(
            button_frame,
            text="ç«‹å³æ›´æ–°",
            command=self.start_update,
            font=("Microsoft YaHei UI", 12)
        )
        self.update_btn.pack(side="left", expand=True, padx=5)
        
        self.cancel_btn = ctk.CTkButton(
            button_frame,
            text="ç¨åæé†’",
            command=self.destroy,
            font=("Microsoft YaHei UI", 12),
            fg_color="gray"
        )
        self.cancel_btn.pack(side="left", expand=True, padx=5)
        
    def start_update(self):
        """å¼€å§‹æ›´æ–°"""
        self.update_btn.configure(state="disabled")
        self.cancel_btn.configure(state="disabled")
        self.progress_frame.pack(fill="x", padx=20, pady=10)
        
        # å¼‚æ­¥ä¸‹è½½
        self.download_task = asyncio.create_task(self.download_and_install())
        
    async def download_and_install(self):
        """ä¸‹è½½å¹¶å®‰è£…æ›´æ–°"""
        def progress_callback(downloaded, total):
            """è¿›åº¦å›è°ƒ"""
            if total > 0:
                progress = downloaded / total
                self.progress_bar.set(progress)
                
                downloaded_mb = downloaded / (1024 * 1024)
                total_mb = total / (1024 * 1024)
                self.progress_label.configure(
                    text=f"ä¸‹è½½ä¸­... {downloaded_mb:.1f}/{total_mb:.1f} MB ({progress*100:.1f}%)"
                )
        
        try:
            # ä¸‹è½½æ›´æ–°
            update_package = await self.update_manager.check_and_download(progress_callback)
            
            if not update_package:
                self.progress_label.configure(text="âŒ ä¸‹è½½å¤±è´¥")
                self.update_btn.configure(state="normal")
                self.cancel_btn.configure(state="normal")
                return
            
            self.progress_label.configure(text="âœ… ä¸‹è½½å®Œæˆï¼Œå‡†å¤‡å®‰è£…...")
            
            # å®‰è£…æ›´æ–°
            success = self.update_manager.install_update(update_package)
            
            if success:
                self.progress_label.configure(text="ğŸ‰ æ›´æ–°ç¨‹åºå·²å¯åŠ¨ï¼Œåº”ç”¨å³å°†é‡å¯...")
                await asyncio.sleep(2)
                
                # é€€å‡ºåº”ç”¨
                import sys
                sys.exit(0)
            else:
                self.progress_label.configure(text="âŒ å¯åŠ¨æ›´æ–°ç¨‹åºå¤±è´¥")
                self.update_btn.configure(state="normal")
                self.cancel_btn.configure(state="normal")
                
        except Exception as e:
            self.progress_label.configure(text=f"âŒ é”™è¯¯: {e}")
            self.update_btn.configure(state="normal")
            self.cancel_btn.configure(state="normal")


# åœ¨ä¸»çª—å£ä¸­æ·»åŠ æ›´æ–°æ£€æŸ¥
class MainWindow(ctk.CTk):
    """ä¸»çª—å£"""
    
    def __init__(self):
        super().__init__()
        
        # ... å…¶ä»–åˆå§‹åŒ–ä»£ç  ...
        
        # å¯åŠ¨æ—¶æ£€æŸ¥æ›´æ–°
        self.after(3000, self.check_for_updates)  # 3ç§’åæ£€æŸ¥
        
    def check_for_updates(self):
        """æ£€æŸ¥æ›´æ–°"""
        async def _check():
            checker = UpdateChecker()
            update_info = await checker.check_for_updates()
            
            if update_info:
                # æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
                dialog = UpdateDialog(self, update_info)
                dialog.grab_set()  # æ¨¡æ€å¯¹è¯æ¡†
        
        asyncio.create_task(_check())
```

---

## ğŸ“¦ æ‰“åŒ…é…ç½®

### PyInstaller é…ç½®

```python
# build/build_with_updater.py

import PyInstaller.__main__

# æ‰“åŒ…ä¸»ç¨‹åº
PyInstaller.__main__.run([
    'main.py',
    '--name=JieDimension-Toolkit',
    '--windowed',
    '--onefile',
    '--icon=assets/icons/app.ico',
    '--add-data=assets;assets',
    '--add-data=config;config',
    '--hidden-import=customtkinter',
    '--hidden-import=PIL',
    # ... å…¶ä»–é…ç½® ...
])

# æ‰“åŒ…æ›´æ–°ç¨‹åº
PyInstaller.__main__.run([
    'core/update_installer.py',
    '--name=update_installer',
    '--onefile',
    '--console',  # æ˜¾ç¤ºæ§åˆ¶å°
    '--icon=assets/icons/updater.ico',
])
```

---

## ğŸš€ ä½¿ç”¨æµç¨‹

### å¼€å‘è€…ç«¯

1. **å‡†å¤‡æ–°ç‰ˆæœ¬**
   ```bash
   # æ›´æ–°ç‰ˆæœ¬å·
   # ä¿®æ”¹ core/version.py ä¸­çš„ CURRENT_VERSION
   
   # æ‰“åŒ…
   python build/build_with_updater.py
   
   # åˆ›å»ºæ›´æ–°åŒ…
   cd dist
   zip -r v1.17.0.zip JieDimension-Toolkit/
   ```

2. **ä¸Šä¼ åˆ°æœåŠ¡å™¨**
   ```bash
   # ä¸Šä¼ æ›´æ–°åŒ…
   scp v1.17.0.zip server:/var/www/updates/
   
   # ç”ŸæˆMD5
   md5sum v1.17.0.zip
   
   # æ›´æ–° latest.json
   # åŒ…å«ç‰ˆæœ¬å·ã€ä¸‹è½½é“¾æ¥ã€MD5ç­‰
   ```

### ç”¨æˆ·ç«¯

1. **è‡ªåŠ¨æ£€æŸ¥** - å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æŸ¥æ›´æ–°
2. **æ‰‹åŠ¨æ£€æŸ¥** - èœå• â†’ å¸®åŠ© â†’ æ£€æŸ¥æ›´æ–°
3. **ä¸‹è½½æ›´æ–°** - ç‚¹å‡»"ç«‹å³æ›´æ–°"
4. **è‡ªåŠ¨å®‰è£…** - ä¸‹è½½å®Œæˆåè‡ªåŠ¨å®‰è£…å¹¶é‡å¯

---

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. æ–‡ä»¶éªŒè¯
- âœ… MD5æ ¡éªŒï¼ˆé˜²æ­¢æ–‡ä»¶æŸåï¼‰
- âœ… HTTPSä¸‹è½½ï¼ˆé˜²æ­¢ä¸­é—´äººæ”»å‡»ï¼‰
- âœ… æ•°å­—ç­¾åï¼ˆå¯é€‰ï¼Œé˜²æ­¢ç¯¡æ”¹ï¼‰

### 2. ç‰ˆæœ¬æ£€æŸ¥
- âœ… æœ€ä½æ”¯æŒç‰ˆæœ¬ï¼ˆé¿å…è·¨å¤§ç‰ˆæœ¬æ›´æ–°ï¼‰
- âœ… å¼ºåˆ¶æ›´æ–°æ ‡å¿—ï¼ˆä¸¥é‡Bugæ—¶å¼ºåˆ¶ï¼‰

### 3. å¤‡ä»½æœºåˆ¶
- âœ… è‡ªåŠ¨å¤‡ä»½æ—§ç‰ˆæœ¬
- âœ… æ›´æ–°å¤±è´¥è‡ªåŠ¨å›æ»š

---

## ğŸ“ æ³¨æ„äº‹é¡¹

### 1. ç¬¬ä¸€æ¬¡å‘å¸ƒ
- æ‰“åŒ…æ—¶å¿…é¡»åŒ…å« `update_installer.exe`
- é…ç½®æ–‡ä»¶ä¸­è®¾ç½®æ›´æ–°æœåŠ¡å™¨åœ°å€

### 2. æ•°æ®å…¼å®¹æ€§
- æ•°æ®åº“ç»“æ„å˜æ›´éœ€è¦è¿ç§»è„šæœ¬
- é…ç½®æ–‡ä»¶æ ¼å¼å˜æ›´éœ€è¦è½¬æ¢

### 3. ç”¨æˆ·ä½“éªŒ
- æ›´æ–°è¿‡ç¨‹ä¸è¦è¶…è¿‡30ç§’
- æä¾›è¯¦ç»†çš„è¿›åº¦æç¤º
- å¤±è´¥æ—¶ç»™å‡ºæ˜ç¡®çš„é”™è¯¯ä¿¡æ¯

---

## ğŸ¯ æœªæ¥ä¼˜åŒ–

### v2.0 å¯èƒ½çš„æ”¹è¿›
- [ ] å¢é‡æ›´æ–°ï¼ˆåªä¸‹è½½å˜æ›´æ–‡ä»¶ï¼‰
- [ ] æ–­ç‚¹ç»­ä¼ ï¼ˆç½‘ç»œä¸­æ–­åç»§ç»­ï¼‰
- [ ] å¤šçº¿ç¨‹ä¸‹è½½ï¼ˆæå‡é€Ÿåº¦ï¼‰
- [ ] æ›´æ–°å›æ»šï¼ˆä¸€é”®æ¢å¤æ—§ç‰ˆæœ¬ï¼‰
- [ ] æ›´æ–°æ—¥å¿—åœ¨çº¿é¢„è§ˆ
- [ ] è‡ªå®šä¹‰æ›´æ–°æ£€æŸ¥é¢‘ç‡

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ‰“åŒ…è„šæœ¬](../build/build.py)
- [ç‰ˆæœ¬ç®¡ç†](../core/version.py)
- [éƒ¨ç½²æŒ‡å—](./éƒ¨ç½²æŒ‡å—.md)

---

**åˆ›å»ºæ—¶é—´**: 2025-10-09  
**çŠ¶æ€**: è®¾è®¡å®Œæˆï¼Œå¾…å®ç°  
**ä¼˜å…ˆçº§**: ä¸­ï¼ˆå¯åœ¨v1.17.0å®ç°ï¼‰


