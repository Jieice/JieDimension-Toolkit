# 🔄 JieDimension Toolkit - 热更新设计方案

> **版本**: v1.0  
> **日期**: 2025-10-09  
> **状态**: 设计阶段

---

## 📋 需求分析

### 用户需求
- 用户无需重新下载完整安装包
- 应用内一键更新
- 更新过程自动化
- 保留用户数据和配置

### 技术挑战
- **exe无法自我更新**: Windows不允许正在运行的exe修改自身
- **数据迁移**: 需要保留数据库和配置
- **版本兼容**: 新旧版本数据结构可能不同
- **网络问题**: 下载失败需要重试机制

---

## 🎯 推荐方案：双进程更新

### 原理
1. **主程序**: 检查更新 → 下载新版本 → 启动更新程序 → 退出
2. **更新程序**: 等待主程序退出 → 替换exe → 重启主程序

### 优势
- ✅ 安全可靠（主程序退出后才更新）
- ✅ 用户体验好（一键更新）
- ✅ 支持断点续传
- ✅ 回滚机制（备份旧版本）

---

## 🏗️ 架构设计

### 1. 版本服务器
```
https://your-server.com/updates/
├── latest.json          # 最新版本信息
├── v1.16.0.zip         # 版本包
├── v1.17.0.zip
└── changelog.json      # 更新日志
```

#### latest.json 格式
```json
{
  "version": "1.17.0",
  "release_date": "2025-10-15",
  "download_url": "https://your-server.com/updates/v1.17.0.zip",
  "file_size": 52428800,
  "md5": "abc123...",
  "min_version": "1.15.0",
  "changelog": [
    "新增: 抖音插件支持",
    "修复: 闲鱼发布Bug",
    "优化: 提升50%性能"
  ],
  "force_update": false
}
```

### 2. 更新模块结构
```
core/
├── updater.py              # 更新检查器（主程序）
├── update_installer.py     # 更新安装器（独立exe）
└── version.py              # 版本管理

utils/
└── download_manager.py     # 下载管理器
```

---

## 💻 代码实现

### 1. 版本管理器 (core/version.py)

```python
"""
版本管理模块
"""
import json
from pathlib import Path
from typing import Dict, Optional, Tuple

class VersionManager:
    """版本管理器"""
    
    CURRENT_VERSION = "1.16.0"  # 当前版本
    VERSION_FILE = "version.json"
    
    @classmethod
    def get_current_version(cls) -> str:
        """获取当前版本"""
        return cls.CURRENT_VERSION
    
    @classmethod
    def parse_version(cls, version: str) -> Tuple[int, int, int]:
        """解析版本号"""
        try:
            major, minor, patch = version.split('.')
            return int(major), int(minor), int(patch)
        except:
            return (0, 0, 0)
    
    @classmethod
    def compare_versions(cls, v1: str, v2: str) -> int:
        """
        比较版本号
        
        Returns:
            1: v1 > v2
            0: v1 == v2
           -1: v1 < v2
        """
        v1_tuple = cls.parse_version(v1)
        v2_tuple = cls.parse_version(v2)
        
        if v1_tuple > v2_tuple:
            return 1
        elif v1_tuple < v2_tuple:
            return -1
        else:
            return 0
    
    @classmethod
    def is_newer(cls, new_version: str) -> bool:
        """检查是否有新版本"""
        return cls.compare_versions(new_version, cls.CURRENT_VERSION) > 0
```

### 2. 更新检查器 (core/updater.py)

```python
"""
更新检查和下载模块
"""
import json
import asyncio
import aiohttp
import hashlib
from pathlib import Path
from typing import Optional, Dict, Callable
import logging

from core.version import VersionManager

logger = logging.getLogger(__name__)

class UpdateChecker:
    """更新检查器"""
    
    def __init__(self, update_url: str = "https://your-server.com/updates/latest.json"):
        self.update_url = update_url
        self.version_manager = VersionManager()
        
    async def check_for_updates(self) -> Optional[Dict]:
        """
        检查更新
        
        Returns:
            更新信息字典，无更新返回None
        """
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(self.update_url, timeout=10) as response:
                    if response.status == 200:
                        update_info = await response.json()
                        
                        # 检查是否有新版本
                        if self.version_manager.is_newer(update_info['version']):
                            logger.info(f"发现新版本: {update_info['version']}")
                            return update_info
                        else:
                            logger.info("当前已是最新版本")
                            return None
                    else:
                        logger.error(f"检查更新失败: HTTP {response.status}")
                        return None
        except Exception as e:
            logger.error(f"检查更新异常: {e}")
            return None
    
    async def download_update(
        self, 
        download_url: str, 
        save_path: Path,
        progress_callback: Optional[Callable] = None
    ) -> bool:
        """
        下载更新文件
        
        Args:
            download_url: 下载链接
            save_path: 保存路径
            progress_callback: 进度回调函数(downloaded, total)
            
        Returns:
            是否下载成功
        """
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(download_url) as response:
                    if response.status != 200:
                        logger.error(f"下载失败: HTTP {response.status}")
                        return False
                    
                    total_size = int(response.headers.get('content-length', 0))
                    downloaded = 0
                    
                    # 创建保存目录
                    save_path.parent.mkdir(parents=True, exist_ok=True)
                    
                    # 下载文件
                    with open(save_path, 'wb') as f:
                        async for chunk in response.content.iter_chunked(8192):
                            f.write(chunk)
                            downloaded += len(chunk)
                            
                            # 回调进度
                            if progress_callback:
                                progress_callback(downloaded, total_size)
                    
                    logger.info(f"下载完成: {save_path}")
                    return True
                    
        except Exception as e:
            logger.error(f"下载异常: {e}")
            return False
    
    def verify_file(self, file_path: Path, expected_md5: str) -> bool:
        """
        验证文件MD5
        
        Args:
            file_path: 文件路径
            expected_md5: 期望的MD5值
            
        Returns:
            是否验证通过
        """
        try:
            md5 = hashlib.md5()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(8192), b''):
                    md5.update(chunk)
            
            actual_md5 = md5.hexdigest()
            if actual_md5 == expected_md5:
                logger.info("文件校验通过")
                return True
            else:
                logger.error(f"文件校验失败: {actual_md5} != {expected_md5}")
                return False
                
        except Exception as e:
            logger.error(f"文件校验异常: {e}")
            return False


class UpdateManager:
    """更新管理器"""
    
    def __init__(self):
        self.checker = UpdateChecker()
        self.update_dir = Path("updates")
        self.backup_dir = Path("backup")
        
    async def check_and_download(
        self, 
        progress_callback: Optional[Callable] = None
    ) -> Optional[Path]:
        """
        检查并下载更新
        
        Args:
            progress_callback: 进度回调
            
        Returns:
            下载的更新包路径，无更新返回None
        """
        # 检查更新
        update_info = await self.checker.check_for_updates()
        if not update_info:
            return None
        
        # 下载更新
        version = update_info['version']
        download_url = update_info['download_url']
        save_path = self.update_dir / f"v{version}.zip"
        
        success = await self.checker.download_update(
            download_url, 
            save_path, 
            progress_callback
        )
        
        if not success:
            return None
        
        # 验证文件
        if not self.checker.verify_file(save_path, update_info['md5']):
            save_path.unlink()  # 删除损坏的文件
            return None
        
        return save_path
    
    def install_update(self, update_package: Path) -> bool:
        """
        安装更新（调用更新程序）
        
        Args:
            update_package: 更新包路径
            
        Returns:
            是否成功启动更新程序
        """
        import subprocess
        import sys
        
        try:
            # 启动更新程序
            updater_exe = Path("update_installer.exe")
            if not updater_exe.exists():
                logger.error("更新程序不存在")
                return False
            
            # 参数：更新包路径、主程序路径
            main_exe = Path(sys.executable)
            
            subprocess.Popen([
                str(updater_exe),
                str(update_package),
                str(main_exe)
            ])
            
            logger.info("更新程序已启动")
            return True
            
        except Exception as e:
            logger.error(f"启动更新程序失败: {e}")
            return False
```

### 3. 更新安装器 (core/update_installer.py)

```python
"""
更新安装器（独立程序）
"""
import sys
import time
import shutil
import zipfile
from pathlib import Path
import psutil

def wait_for_process_exit(process_path: Path, timeout: int = 30):
    """等待进程退出"""
    process_name = process_path.name
    
    start_time = time.time()
    while time.time() - start_time < timeout:
        # 检查进程是否还在运行
        found = False
        for proc in psutil.process_iter(['name', 'exe']):
            try:
                if proc.info['name'] == process_name:
                    found = True
                    break
            except:
                pass
        
        if not found:
            return True
        
        time.sleep(0.5)
    
    return False

def backup_current_version(exe_path: Path, backup_dir: Path):
    """备份当前版本"""
    backup_dir.mkdir(parents=True, exist_ok=True)
    backup_path = backup_dir / f"{exe_path.stem}_backup.exe"
    shutil.copy2(exe_path, backup_path)
    print(f"已备份到: {backup_path}")

def install_update(update_zip: Path, target_dir: Path):
    """安装更新"""
    print(f"解压更新包: {update_zip}")
    
    with zipfile.ZipFile(update_zip, 'r') as zip_ref:
        zip_ref.extractall(target_dir)
    
    print("更新安装完成")

def restart_application(exe_path: Path):
    """重启应用"""
    import subprocess
    print(f"重启应用: {exe_path}")
    subprocess.Popen([str(exe_path)])

def main():
    """主函数"""
    if len(sys.argv) < 3:
        print("用法: update_installer.exe <update_zip> <main_exe>")
        sys.exit(1)
    
    update_zip = Path(sys.argv[1])
    main_exe = Path(sys.argv[2])
    
    print("=" * 50)
    print("JieDimension Toolkit - 更新安装器")
    print("=" * 50)
    
    # 1. 等待主程序退出
    print("\n等待主程序退出...")
    if not wait_for_process_exit(main_exe):
        print("错误: 主程序未能正常退出")
        sys.exit(1)
    
    time.sleep(1)  # 额外等待
    
    # 2. 备份当前版本
    print("\n备份当前版本...")
    backup_dir = main_exe.parent / "backup"
    try:
        backup_current_version(main_exe, backup_dir)
    except Exception as e:
        print(f"警告: 备份失败 - {e}")
    
    # 3. 安装更新
    print("\n安装更新...")
    try:
        install_update(update_zip, main_exe.parent)
    except Exception as e:
        print(f"错误: 安装失败 - {e}")
        sys.exit(1)
    
    # 4. 清理更新包
    print("\n清理更新包...")
    try:
        update_zip.unlink()
    except:
        pass
    
    # 5. 重启应用
    print("\n重启应用...")
    time.sleep(1)
    restart_application(main_exe)
    
    print("\n更新完成！")
    time.sleep(2)

if __name__ == "__main__":
    main()
```

### 4. GUI更新界面 (ui/update_dialog.py)

```python
"""
更新对话框
"""
import customtkinter as ctk
import asyncio
from pathlib import Path
from typing import Optional

from core.updater import UpdateManager

class UpdateDialog(ctk.CTkToplevel):
    """更新对话框"""
    
    def __init__(self, parent, update_info: dict):
        super().__init__(parent)
        
        self.update_info = update_info
        self.update_manager = UpdateManager()
        self.download_task = None
        
        self.setup_ui()
        
    def setup_ui(self):
        """设置界面"""
        self.title("发现新版本")
        self.geometry("500x400")
        self.resizable(False, False)
        
        # 版本信息
        info_frame = ctk.CTkFrame(self)
        info_frame.pack(fill="x", padx=20, pady=20)
        
        ctk.CTkLabel(
            info_frame,
            text=f"🎉 发现新版本 v{self.update_info['version']}",
            font=("Microsoft YaHei UI", 16, "bold")
        ).pack(pady=10)
        
        ctk.CTkLabel(
            info_frame,
            text=f"发布日期: {self.update_info['release_date']}",
            font=("Microsoft YaHei UI", 12)
        ).pack()
        
        size_mb = self.update_info['file_size'] / (1024 * 1024)
        ctk.CTkLabel(
            info_frame,
            text=f"更新大小: {size_mb:.1f} MB",
            font=("Microsoft YaHei UI", 12)
        ).pack()
        
        # 更新日志
        changelog_frame = ctk.CTkFrame(self)
        changelog_frame.pack(fill="both", expand=True, padx=20, pady=10)
        
        ctk.CTkLabel(
            changelog_frame,
            text="📝 更新内容",
            font=("Microsoft YaHei UI", 14, "bold")
        ).pack(pady=5)
        
        changelog_text = ctk.CTkTextbox(changelog_frame, height=150)
        changelog_text.pack(fill="both", expand=True, padx=10, pady=5)
        
        for item in self.update_info['changelog']:
            changelog_text.insert("end", f"• {item}\n")
        changelog_text.configure(state="disabled")
        
        # 进度条
        self.progress_frame = ctk.CTkFrame(self)
        self.progress_frame.pack(fill="x", padx=20, pady=10)
        
        self.progress_bar = ctk.CTkProgressBar(self.progress_frame)
        self.progress_bar.pack(fill="x", pady=5)
        self.progress_bar.set(0)
        
        self.progress_label = ctk.CTkLabel(
            self.progress_frame,
            text="准备下载...",
            font=("Microsoft YaHei UI", 10)
        )
        self.progress_label.pack()
        
        # 隐藏进度条
        self.progress_frame.pack_forget()
        
        # 按钮
        button_frame = ctk.CTkFrame(self)
        button_frame.pack(fill="x", padx=20, pady=10)
        
        self.update_btn = ctk.CTkButton(
            button_frame,
            text="立即更新",
            command=self.start_update,
            font=("Microsoft YaHei UI", 12)
        )
        self.update_btn.pack(side="left", expand=True, padx=5)
        
        self.cancel_btn = ctk.CTkButton(
            button_frame,
            text="稍后提醒",
            command=self.destroy,
            font=("Microsoft YaHei UI", 12),
            fg_color="gray"
        )
        self.cancel_btn.pack(side="left", expand=True, padx=5)
        
    def start_update(self):
        """开始更新"""
        self.update_btn.configure(state="disabled")
        self.cancel_btn.configure(state="disabled")
        self.progress_frame.pack(fill="x", padx=20, pady=10)
        
        # 异步下载
        self.download_task = asyncio.create_task(self.download_and_install())
        
    async def download_and_install(self):
        """下载并安装更新"""
        def progress_callback(downloaded, total):
            """进度回调"""
            if total > 0:
                progress = downloaded / total
                self.progress_bar.set(progress)
                
                downloaded_mb = downloaded / (1024 * 1024)
                total_mb = total / (1024 * 1024)
                self.progress_label.configure(
                    text=f"下载中... {downloaded_mb:.1f}/{total_mb:.1f} MB ({progress*100:.1f}%)"
                )
        
        try:
            # 下载更新
            update_package = await self.update_manager.check_and_download(progress_callback)
            
            if not update_package:
                self.progress_label.configure(text="❌ 下载失败")
                self.update_btn.configure(state="normal")
                self.cancel_btn.configure(state="normal")
                return
            
            self.progress_label.configure(text="✅ 下载完成，准备安装...")
            
            # 安装更新
            success = self.update_manager.install_update(update_package)
            
            if success:
                self.progress_label.configure(text="🎉 更新程序已启动，应用即将重启...")
                await asyncio.sleep(2)
                
                # 退出应用
                import sys
                sys.exit(0)
            else:
                self.progress_label.configure(text="❌ 启动更新程序失败")
                self.update_btn.configure(state="normal")
                self.cancel_btn.configure(state="normal")
                
        except Exception as e:
            self.progress_label.configure(text=f"❌ 错误: {e}")
            self.update_btn.configure(state="normal")
            self.cancel_btn.configure(state="normal")


# 在主窗口中添加更新检查
class MainWindow(ctk.CTk):
    """主窗口"""
    
    def __init__(self):
        super().__init__()
        
        # ... 其他初始化代码 ...
        
        # 启动时检查更新
        self.after(3000, self.check_for_updates)  # 3秒后检查
        
    def check_for_updates(self):
        """检查更新"""
        async def _check():
            checker = UpdateChecker()
            update_info = await checker.check_for_updates()
            
            if update_info:
                # 显示更新对话框
                dialog = UpdateDialog(self, update_info)
                dialog.grab_set()  # 模态对话框
        
        asyncio.create_task(_check())
```

---

## 📦 打包配置

### PyInstaller 配置

```python
# build/build_with_updater.py

import PyInstaller.__main__

# 打包主程序
PyInstaller.__main__.run([
    'main.py',
    '--name=JieDimension-Toolkit',
    '--windowed',
    '--onefile',
    '--icon=assets/icons/app.ico',
    '--add-data=assets;assets',
    '--add-data=config;config',
    '--hidden-import=customtkinter',
    '--hidden-import=PIL',
    # ... 其他配置 ...
])

# 打包更新程序
PyInstaller.__main__.run([
    'core/update_installer.py',
    '--name=update_installer',
    '--onefile',
    '--console',  # 显示控制台
    '--icon=assets/icons/updater.ico',
])
```

---

## 🚀 使用流程

### 开发者端

1. **准备新版本**
   ```bash
   # 更新版本号
   # 修改 core/version.py 中的 CURRENT_VERSION
   
   # 打包
   python build/build_with_updater.py
   
   # 创建更新包
   cd dist
   zip -r v1.17.0.zip JieDimension-Toolkit/
   ```

2. **上传到服务器**
   ```bash
   # 上传更新包
   scp v1.17.0.zip server:/var/www/updates/
   
   # 生成MD5
   md5sum v1.17.0.zip
   
   # 更新 latest.json
   # 包含版本号、下载链接、MD5等
   ```

### 用户端

1. **自动检查** - 启动时自动检查更新
2. **手动检查** - 菜单 → 帮助 → 检查更新
3. **下载更新** - 点击"立即更新"
4. **自动安装** - 下载完成后自动安装并重启

---

## 🔒 安全考虑

### 1. 文件验证
- ✅ MD5校验（防止文件损坏）
- ✅ HTTPS下载（防止中间人攻击）
- ✅ 数字签名（可选，防止篡改）

### 2. 版本检查
- ✅ 最低支持版本（避免跨大版本更新）
- ✅ 强制更新标志（严重Bug时强制）

### 3. 备份机制
- ✅ 自动备份旧版本
- ✅ 更新失败自动回滚

---

## 📝 注意事项

### 1. 第一次发布
- 打包时必须包含 `update_installer.exe`
- 配置文件中设置更新服务器地址

### 2. 数据兼容性
- 数据库结构变更需要迁移脚本
- 配置文件格式变更需要转换

### 3. 用户体验
- 更新过程不要超过30秒
- 提供详细的进度提示
- 失败时给出明确的错误信息

---

## 🎯 未来优化

### v2.0 可能的改进
- [ ] 增量更新（只下载变更文件）
- [ ] 断点续传（网络中断后继续）
- [ ] 多线程下载（提升速度）
- [ ] 更新回滚（一键恢复旧版本）
- [ ] 更新日志在线预览
- [ ] 自定义更新检查频率

---

## 📚 相关文档

- [打包脚本](../build/build.py)
- [版本管理](../core/version.py)
- [部署指南](./部署指南.md)

---

**创建时间**: 2025-10-09  
**状态**: 设计完成，待实现  
**优先级**: 中（可在v1.17.0实现）


